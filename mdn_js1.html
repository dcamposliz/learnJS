<!DOCTYPE html>
<html>
<head>
	<title>Learn JS 1</title>
</head>
<body>
	<h1>Open Console in DevTools to see JS Output</h1>

	<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank">
		<h2>
			Keep reading this !!
		</h2>
	</a>

	<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Introduction_to_Object-Oriented_JavaScript" target="_blank">Then read this!</a>
	

<!-- NOW, THIS IS THE RELEVANT STUFF -->	

	<script type="text/javascript">

// playing with math
console.log("\n\n\tJS Math\n\n");

	var a = (0.1 + 0.2);
	console.log(a);
	
	var b = Math.sin(3.5);
	console.log(b, "This is the sine of 3.5");

	var r = 1;
	var c = Math.PI * (r);
	console.log(r);
	console.log(c, "The Math.PI property represents the ratio of the circumpherence of a circle to its diameter. It basically multiplies whatever arguments it is passed times the numerical value of pi");

	var pa1 = parseInt("123", 10);
	console.log(pa1);

	var pa2 = parseInt("12344.3423", 10);
	console.log(pa2);

	var pa3 = parseInt("11", 2);
	console.log(pa3);

	var pa4 = parseInt("Simon", 10);
	console.log(pa4);

	var pa5 = parseFloat("23123.23123");
	console.log(pa5);

	var pa6 = parseFloat("23123");
	console.log(pa6);

	console.log();

	console.log(NaN + 5);

	console.log(isNaN(NaN));

	console.log(1/0);

	console.log(-1/0);

	console.log(isFinite(1/0));

	console.log(isFinite(-Infinity));

	console.log(NaN);

	// playing with strings
console.log("\n\n\tJS Strings\n\n");

	console.log("hello".length);

	console.log("hello".charAt(0));

	console.log("hello, world".replace("hello", "goodbye"));

	// two examples of using toUpperCase

	console.log("helloYo".toUpperCase());

	var hello = "hello"
	var uphello = hello.toUpperCase();
	console.log(uphello);

	// playing with booleans
console.log("\n\n\tJS Booleans & Other\n\n");

	console.log(Boolean(""));

	console.log(Boolean(2342335));

	console.log(Boolean("String!"));

	var sdfs;
	console.log(typeof(sdfs));
	// this outputs 'undefined' data type

	var simon = "This is the Simon string"
	console.log(typeof(simon));

	var numberVariable = 856973;
	console.log(typeof(numberVariable));

	// in JS, blocks do not have scope, only functions have scope

	// need to learn more about the let and const declarations

	// operators are +, -, *, /, and %
	// also +=
	// and -=
	// and ++
	// and --

	var weirdNum = "3" + 4 + 5;
	console.log(weirdNum);

	var weirdNum2 = 3 + 4 + "5";
	console.log(weirdNum2);

	var equal2 = "dog" == "dog";
	console.log(equal2);
	// equal2 takes the boolean value of true, because it is true that dog is equal to dog

	var equal3 = 1 == true;
	console.log(equal3);
	// this outputs true because we run into type coersion - look up type coersion smartie pants!

// playing CONTROL STRUCTURES!
console.log("\n\n\tJS Control Structures: If then, loops, etc\n\n");

	var name = "kittens";
	console.log(name);
		if (name == "puppies"){
			name += "!";
		} else if (name = "kittens") {
			name += "!!";
		} else {
			name = "!" + name;
		}
	console.log(name)
	// here we apply some basic logic and concatenation on strings


	// below is an example of a commented-out infinite while loop
		/*
			while(true){
				// this is an infinite loop
				// it is commented out because otherwise it'd crash the machine :o
			}
		*/
		
	// below is an example of a do while loop, which takes arguments that have not been defined yet, hence I am commenting it out
		/*
			var input;
			do {
				input = get_input();
			} while (inputIsNotValid(input))
		*/

	// and finally, a for loop
		for (var i = 0; i < 5; i++){
			console.log(i);
			// this executes 5 times
		}

	// we also have && which is the logical AND
	// as well as || which is the logical OR
	// and ! which is the logical NOT


	// HELP!! HOW DO I MAKE THIS WORK WITHOUT IT BREAKING MY SHIT?
		/*
			var o = "Omar"
			var name = o && o.getName();

			var name = othername || "default";
		*/

	// okay, this is cool
	var age = 17;
	var allowed = (age > 18) ? "yes" : "no";
	console.log(age);
	console.log(allowed);

	//switch stuff!

	switch(2+2){
		case 4:
			console.log("yay!");
			break;
		case 'eat':
			console.log("no-yay");
			break;
		default:
			console.log("whatever");
	}

// LEARNING OBJECTS
console.log("\n\n\tJS OBJECTS\n\n");

	/*
		Objects can be thought of as simple collections of name-value pairs, or key value pairs.

		DEF: A key-value pair (KVP) is a set of two linked data items: a key, which is a unique identifier for some item of data, and the value, which is either the data that is identified or a pointer to the location of that data. Key-value pairs are frequently used in lookup tables, hash tables and configuration files.

		The name, or key, is typically a string.

		While the key can be any JS value - including objects.
	*/


	var obj1 = new Object();
	console.log(obj1);

	// I am curious about how to check if the object is empty

	var obj2 = {};
	console.log(obj2);

	var obj3 = {
		name: "Carrot",
		"for": "Max"
	}
	console.log(obj3);
	// why do we put quotes around for?

	// we are creating an object with three attributes
	var obj4 = {
		name: "Cup",
		color: "Orange",
		weight: "So heavy"
	}
	console.log(obj4);

	// FIGURE 'THIS' OUT
		/*
		var obj5 = {
			test:function(){
				var other = "this"
				return this.name + other;
			},
			othertest:function(){
				return this.name + other;
			},
			name: "Yoyo",
			details: {
				owner: "David",
				color: "Red",
				brand: "Duncan",
				length_in: 46,
				weight_oz: 34.54
			}
		}
		*/

	var obj5 = {
		name: "Yoyo",
		details: {
			owner: "David",
			color: "Red",
			brand: "Duncan",
			length_in: 46,
			weight_oz: 34.54
		}
	}


	console.log(obj5);
	console.log(obj5.details.color);
	console.log(obj5["details"]["owner"]);
	console.log(obj5["details"]["weight_oz"]);


	//so this is a CONSTRUCTOR function
	var Person = function(name, age){
		this.name = name;
		this.age = age;
	}
	console.log(Person);

	var David = new Person("David", 25);
	console.log(David);

	console.log(David.name);

	David.name = "David A Campos";
	David.major = "Economics";
	
	console.log(David);

	var test = function(name, age, major){
		this.name = name;
		this.age = age;
		this.major = major;
	}

	console.log(David);


	var Sarah = new Person("Sarah", 25)

	console.log(Person);
	console.log(Sarah);

	Sarah.age = 26;
	console.log(Sarah);

	Sarah.name = "Sarah SeaGrave"
	console.log(Sarah);

	Sarah.age = 25;
	console.log(Sarah);

	console.log(Sarah.name);
	console.log(Sarah.age);

	var color = Sarah.color;
	console.log(Sarah);

// LEARNING ARRAYS
console.log("\n\n\tJS ARRAYS\n\n");
	
	// below we are defining a new array with its elements within
	var arr1 = new Array();
		arr1[0] = "dog";
		arr1[1] = "cat";
		arr1[2] = "chicken";
	console.log(typeof(arr1));
	console.log(arr1);
	console.log(arr1.length);

	// here we are creating another array, and playing with the different elements within, and what they do
	var arr2 = ["one", "two", "three"];
	arr2[15] = "fox";
	console.log(arr2);
	console.log(typeof arr2[2]);
	console.log(typeof arr2[5]);
	console.log(typeof arr2[15]);
	console.log(typeof arr2[16]);
	console.log(arr2.length);

	// here we are running a for-loop function on the array that tells us how many elements there are within
	for (var i = 0; i < arr2.length; i++){
		console.log(i);
	}

	// 	here we are running a similar function, that tells us how many elements there are within
	console.log("That told us how many items there are in the array.. but im skeptical");

	for (var j = 0, len = arr2.length; j < len; j++){
		console.log(j);
	}

	console.log("This gives us the same amount of iterations, however");

	// same thing, different approach, and our function gets stuck at three, for some reason, which, honestly is kind of annoying
	for (var k = 0, item; item = arr2[k++];){
		console.log(k);
		console.log(item);
	}
	// interesting how console.log(k) outputs an integer
	// and console.log(item) outputs a string
	console.log("Why does this get stuck at 3?");
	console.log("it stops because it finds undefined objects!");


	//learning the forEach() idiom, or method?
		var arr3 = ["zero", "yellow", "fan"]
		console.log(arr3);

		
		// forEach() syntax:
		arr3.forEach(function(currentValue, index, array){
			// do something
		});

		// forEach() example:
		function logArrayElements(element, index, array){
			console.log('a[' + index + '] = ' + element);
		}
			// notice how we didnt have to define 'element', 'index', or 'array' in our function
			// this is interesting when running the console.log 

		// executing forEach() on arr3
			/*
				This is interesting!
				when running forEach() with logArrayElements() as a parameter,
				forEach() adopts as parameters, the parameters we had previously defined for logArrayElements();

				That is why changing the order of the parameters within logArray elements does affect the output of forEach(), when we run it on arr3
			*/			
		arr3.forEach(logArrayElements);


		console.log("let's now run the same function on an array that contains undefined elements!");

		//what happens when we run our function on an array that contains undefined elements?
		arr2.forEach(logArrayElements);
		//it prints without a hick-up!
		// outputs what it needs to, and skips undefined elements

	//THIS IS ON OBJECTS

		// now we are playing with a fucntion that copies an object - let's dissect it!
			// defining function, which takes parameter o for object
			function copy(o){
				//defining variable named copy, equal to some pre-existing methods,
				//	seems that create and getPrototypeOf are what we are in for
				var copy = Object.create(Object.getPrototypeOf(o));
				//then we define another variable, propNames, which is also equal to some other methods, getOwnPropertyNames
				// notice how we are running these functions on the object o, defined earlier!
				var propNames = Object.getOwnPropertyNames(o);
				// and then we actually run propNames for each key-value pair element within, which takes parameter name, which I do not think we defined, this might be an inherent JS thing
				propNames.forEach(function(name){
					// then define another variable desc to be equal to getting the method object.getOwnPropertyDescriptor, which takes parameters o and name
					// why doesn't the earlier function 'take' o as a parameter?
					var desc = Object.getOwnPropertyDescriptor(o, name);
					// 
					Object.defineProperty(copy, name, desc);
				// NOTES
				});
				return copy;
			}
					// here is what I think is actually happening:
						/*
							1 - we first define function with parameter object, which we are trying to copy.
							2 - then we 'get' the prototype of object
							3 - then we create a copy of such prototype


						*/

				//defining supersimple object
				var obj10 = {
					a: 1,
					b: 2
				};

				console.log(obj10);

				var obj10_2 = copy(obj10);

				console.log(obj10_2);

	// BACK TO ARRAYS


		var array10 = [
			"dog",
			"cat",
			"bat"
		];
		
		console.log(array10);

		array10.push("fruitFly");

		console.log(array10);

		// I should definitely read more about arrays
		console.log("I should definitely read more about arrays, just look up arrays mdn");
		console.log("same thing with objects, and other things...");


// NOW ONTO FUNCTIONS

		function add(x, y){
			var total = x + y;
			return total;
		}

		function add2(){
			var sum = 0;
			for (var i = 0, j = arguments.length; i < j; i++){
				sum += arguments[i];
			}
			return sum;
		}

		function avg() {
			var sum = 0;
			for (var i = 0, j = arguments.length; i < j; i++) {
				sum += arguments[i];
			}
			return sum / arguments.length;
		}

		function avgArray(arr) {
			var sum = 0;
			for (var i = 0, j = arr.length; i < j; i++) {
				sum += arr[i];
			}
			return sum / arr.length;
		}

		var arrayInts1 = [
			1,
			2,
			3,
			4,
			5,
			6,
			7,
			8,
			9,
			10,
			11,
			12,
			13,
			14
		]

		var someReturn1 = avg.apply(null, arrayInts1);
		console.log(someReturn1);

		var avg45 = function() {
			var sum = 0;
			for (var i = 0, j = arguments.length; i < j; i++) {
				sum += arguments[i];
			}
			return sum / arguments.length;
		}

		// this basically shows that there are various ways of declaring functions, and that some are more explicit than others... how do we run avg45?

		var simon45 = avg45(323423423, 32567346545, 745435654, 345245634754, 542356347)
		console.log(simon45);

		var simon46 = avg45.apply(null, arrayInts1);
		console.log(simon46);

		var a = 1;
		var b = 2;

		(function() {
			var b = 3;
			a += b;
		})();
		console.log(a);
		console.log(b);

	// some function I don't understand:

		function countChars(elm) {
			if (elm.nodeType == 3) { // TEXT_NODE
				return elm.nodeValue.length;
			}
			var count = 0;
			for (var i = 0, child; child = elm.childNodes[i]; i++) {
				count += countChars(child);
			}
			return count;
		}
		// I dont understand this function
		console.log("How do I make this function work?");
		console.log("function is countChars()");
		//this does not seem to be working with strings, arrays, or objects!

	// some other function I don't understand

		var charsInBody = (function counter(elm) {
			if (elm.nodeType == 3) { // TEXT_NODE
				return elm.nodeValue.length;
			}
			var count = 0;
			for (var i = 0, child; child = elm.childNodes[i]; i++) {
				count += counter(child);
			}
			return count;
		})(document.body);
		console.log("How do I make this function work?");
		console.log("function is charsInBody");

// CUSTOM OBJECTS

	
	// custom function I understand !!!!

	function makePerson(first, last) {
		return {
			first: first,
			last: last,
			fullName: function() {
				return this.first + ' ' + this.last;
			},
			fullNameReversed: function() {
				return this.last + ', ' + this.first;
			}
		};
	}

	nF = makePerson("Nate", "Frit")
	nF.fullName();
	nF.fullNameReversed();

	console.log(nF);
	console.log(nF.fullName());
	console.log(nF.fullNameReversed());

	dC = makePerson("David", "Campos");
	console.log(dC);
	console.log(dC.fullName());
	console.log(dC.fullNameReversed());


	


	</script>



</body>
</html>